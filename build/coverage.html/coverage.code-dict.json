{"/home/travis/build/npmtest/node-npmtest-npm_lazy/test.js":"/* istanbul instrument in package npmtest_npm_lazy */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-npm_lazy/lib.npmtest_npm_lazy.js":"/* istanbul instrument in package npmtest_npm_lazy */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_npm_lazy = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_npm_lazy = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-npm_lazy/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-npm_lazy && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_npm_lazy */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_npm_lazy\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_npm_lazy.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_npm_lazy.rollup.js'] =\n            local.assetsDict['/assets.npmtest_npm_lazy.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_npm_lazy.__dirname +\n                    '/lib.npmtest_npm_lazy.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-npm_lazy/node_modules/npm_lazy/server.js":"var http = require('http'),\n    path = require('path'),\n    fs = require('fs'),\n    url = require('url'),\n    log = require('minilog')('app'),\n\n    api = require('./lib/api.js'),\n    Cache = require('./lib/cache.js'),\n    Package = require('./lib/package.js'),\n    Resource = require('./lib/resource.js');\n\nfunction start(config) {\n  var minilog = require('minilog');\n\n  if (config.loggingOpts.logToConsole) {\n    minilog.enable();\n  } else {\n    minilog.disable();\n  }\n\n  if (config.loggingOpts.logToFile) {\n    minilog.pipe(fs.createWriteStream(config.loggingOpts.filename, {flags: 'w'}));\n  }\n\n  // parse proxy config, see https://wiki.archlinux.org/index.php/proxy_settings for an example\n  if (!config.proxy || !config.proxy.http || !config.proxy.https) {\n    config.proxy = {\n      http: (process.env.http_proxy ? process.env.http_proxy : config.proxy.http),\n      https: (process.env.https_proxy ? process.env.https_proxy : config.proxy.https)\n    };\n  }\n\n  if (config.proxy.http) {\n    if (!config.proxy.https) {\n        // fall back to assuming that both http and https use the same proxy\n        config.proxy.https = config.proxy.http;\n    }\n    // parse\n    if (typeof config.proxy.http === 'string') {\n      config.proxy.http = url.parse(config.proxy.http);\n    }\n    if (typeof config.proxy.https === 'string') {\n      config.proxy.https = url.parse(config.proxy.https);\n    }\n  }\n\n  Resource.configure({\n    cache: new Cache({ path: config.cacheDirectory }),\n    logger: log,\n    cacheAge: config.cacheAge,\n    maxRetries: config.maxRetries,\n    timeout: config.httpTimeout,\n    rejectUnauthorized: config.rejectUnauthorized,\n    proxy: config.proxy\n  });\n\n  var packageConfig = {\n    logger: log,\n    externalUrl: config.externalUrl,\n    remoteUrl: config.remoteUrl,\n    rejectUnauthorized: config.rejectUnauthorized\n  };\n\n  Package.configure(packageConfig);\n  api.configure(packageConfig);\n\n  var server = http.createServer();\n\n  server.on('request', function(req, res) {\n    if (config.loggingOpts.logRequesterIP) {\n      log.info(\"Request from ip: \"+req.connection.remoteAddress+ \" for \"+req.url);\n    }\n    if (!api.route(req, res)) {\n      log.error('No route found', req.url);\n      Package.proxy(req, res);\n    }\n  }).listen(config.port, config.host);\n\n  log.info('npm_lazy at', config.host, 'port', config.port);\n  log.info('npm_lazy cache directory:', path.normalize(config.cacheDirectory));\n\n  // log the proxy config\n  Object.keys(config.proxy).forEach(function(proto) {\n    var conf = config.proxy[proto];\n    if (conf) {\n      log.info('Using ' + conf.protocol + '//' + conf.hostname + ':' + conf.port + ' to proxy ' + proto + ' requests.');\n    }\n  });\n\n  /*\n  Resource.get('http://www.lagado.com/proxy-test')._fetchTask(function(err, res) {\n    if(res) {\n      res.pipe(process.stdout);\n    }\n  });\n  */\n}\n\n\n// if this module is the script being run, then load the default config and run\n// makes it possible to call `node server.js` and have it work like before.\n// Alternatively, you can require server.js and then call the start function with a\n// custom config like we do in ./bin/npm_lazy\nif (module == require.main) {\n  start(require('./config.js'));\n}\n\nmodule.exports = start;\n","/home/travis/build/npmtest/node-npmtest-npm_lazy/node_modules/npm_lazy/lib/api.js":"var fs = require('fs'),\n    url = require('url'),\n\n    Router = require('mixu_minimal').Router,\n\n    Package = require('./package.js'),\n    Resource = require('./resource.js'),\n    ETag = require('./etag.js'),\n\n    remoteUrl = 'https://registry.npmjs.com/',\n    logger = console;\n\nvar api = new Router();\n\napi.configure = function(config) {\n  if (typeof config.remoteUrl !== 'undefined') {\n    remoteUrl = config.remoteUrl;\n  }\n  if (typeof config.logger !== 'undefined') {\n    logger = config.logger;\n  }\n};\n\n// GET /package\napi.get(new RegExp('^/([^/]+)$'), function(req, res, match) {\n  var name = match[1];\n  var auth = req.headers.authorization;\n\n  Package.getIndex(name, auth, function(err, fullpath, etag) {\n    if (err) {\n      res.statusCode = err.statusCode || 500;\n      logger.error('[' + res.statusCode + '] Error: ', err);\n      if (err.content) {\n        res.write(err.content);\n      }\n      res.end();\n      return;\n    }\n\n    if (ETag.handle304(req, res, etag)) {\n      return;\n    }\n\n    res.end(JSON.stringify(fullpath));\n  });\n});\n\n// GET /package/download/package-version.tgz\n// GET /package/-/package-version.tgz\napi.get(new RegExp('^/([^/]+)/(-|download)/([^/]+)$'), function(req, res, match) {\n  var name = match[1],\n      name2 = match[2],\n      file = match[3],\n      uri = remoteUrl + name + '/' + name2 + '/' + file;\n  return downloadTar(req, res, uri);\n});\n// GET /@scope/package/-/package-version.tgz\napi.get(new RegExp('^/(@.+)/-/([^/]+)$'), function(req, res, match) {\n  var name = match[1],\n      file = match[2],\n      uri = remoteUrl + name + '/-/' + file;\n  return downloadTar(req, res, uri);\n});\n\nfunction downloadTar(req, res, uri) {\n  // direct cache access - this is a file get, not a metadata get\n  logger.log('cache get', uri);\n  var auth = req.headers.authorization;\n\n  Resource.get(uri, auth)\n          .getReadablePath(function(err, fullpath, etag) {\n            if (err) {\n              res.statusCode = err.statusCode || 500;\n              logger.error('[' + res.statusCode + '] Error: ', err);\n              if (err.content) {\n                res.write(err.content);\n              }\n              res.end();\n              return;\n            }\n\n            if (ETag.handle304(req, res, etag)) {\n              return;\n            }\n\n            res.setHeader('Content-type', 'application/octet-stream');\n            fs.createReadStream(fullpath).pipe(res);\n          });\n}\n\n// /-/ or /package/-/ are special\napi.get(new RegExp('^/-/(.+)$'), Package.proxy);\napi.get(new RegExp('^/(.+)/-(.*)$'), Package.proxy);\n\n// GET /package/version\napi.get(new RegExp('^/([^/]+)/([^/]+)$'), function(req, res, match) {\n  var name = match[1],\n      version = match[2],\n      self = this;\n\n  Package.getVersion(name, version, function(err, fullpath, etag) {\n    if (err) {\n      res.statusCode = err.statusCode || 500;\n      logger.error('[' + res.statusCode + '] Error: ', err);\n      if (err.content) {\n        res.write(err.content);\n      }\n      res.end();\n      return;\n    }\n\n    if (ETag.handle304(req, res, etag)) {\n      return;\n    }\n\n    res.end(JSON.stringify(fullpath));\n  });\n});\n\n\n\nmodule.exports = api;\n","/home/travis/build/npmtest/node-npmtest-npm_lazy/node_modules/npm_lazy/lib/package.js":"var fs = require('fs'),\n    url = require('url'),\n    path = require('path'),\n    http = require('http'),\n    https = require('https'),\n\n    Resource = require('./resource.js');\n\n// configuration\nvar externalUrl, // external URL of npm_lazy\n    remoteUrl = 'https://registry.npmjs.com/', // \"https://registry.npmjs.com/\"\n    remoteIsHttps = (url.parse(remoteUrl).protocol == 'https:'),\n    rejectUnauthorized = true,\n    logger = console;\n\nfunction Package() { }\n\nPackage.configure = function(opts) {\n  if (typeof opts.externalUrl !== 'undefined') {\n    externalUrl = opts.externalUrl;\n  }\n  if (typeof opts.remoteUrl !== 'undefined') {\n    remoteUrl = opts.remoteUrl;\n    remoteIsHttps = (url.parse(remoteUrl).protocol == 'https:');\n  }\n  if (typeof opts.rejectUnauthorized !== 'undefined') {\n    rejectUnauthorized = opts.rejectUnauthorized;\n  }\n  if (typeof opts.logger !== 'undefined') {\n    logger = opts.logger;\n  }\n};\n\n// uncached direct request\nPackage.proxy = function(req, res, message) {\n  // sadly, the simple req.pipe(http.request).pipe(res) type approach\n  // does not quite work, in particular the method and headers will be wrong\n\n  var parsed = url.parse(remoteUrl),\n      opts = {\n        host: parsed.host,\n        port: (parsed.port !== null) ? parsed.port : (remoteIsHttps ? 443 : 80),\n        path: req.url,\n        headers: req.headers,\n        method: req.method\n      };\n  opts.headers.host = parsed.host;\n\n  if (!rejectUnauthorized && parsed.protocol == 'https:') {\n    opts.rejectUnauthorized = false;\n    opts.agent = new https.Agent(opts);\n  }\n\n  message = message || 'not cached';\n  logger.log('Querying the registry (' + message + '):', remoteUrl + req.url.substr(1));\n\n  var outgoing = (remoteIsHttps ? https : http).request(opts, function(pres) {\n    // write headers\n    Object.keys(pres.headers).forEach(function(key) {\n      res.setHeader(key, pres.headers[key]);\n    });\n    // write statuscode\n    res.writeHead(pres.statusCode);\n    // write response\n    pres.pipe(res);\n  });\n\n  req.pipe(outgoing).once('error', function(e) {\n    logger.log('Ignoring query error (not cached):', e);\n    res.statusCode = 500;\n    res.end('{}');\n  });\n\n  // logger.log(req.headers);\n  // req.pipe(process.stdout);\n};\n\nPackage.getIndex = function(pname, auth, onDone) {\n  // package index\n  var uri = remoteUrl + pname,\n      r = Resource.get(uri, auth);\n\n  r.on('fetch-error', function(err, current, max) {\n    logger.log('Fetch failed (' + current + '/' + max + '): ' + uri, err);\n  });\n\n  r.on('fetch-cached', function() {\n    logger.log('[OK] Reusing cached result for ' + uri);\n  });\n\n  r.getReadablePath(function(err, data, etag) {\n    if (err) {\n      return onDone(err);\n    }\n\n    r.removeAllListeners('fetch-error');\n    r.removeAllListeners('fetch-cached');\n\n    return onDone(err, Package._rewriteLocation(JSON.parse(fs.readFileSync(data))), etag);\n  });\n};\n\nPackage.getVersion = function(pname, version, onDone) {\n  // package index\n  var uri = remoteUrl + pname,\n      r = Resource.get(uri);\n\n  r.on('fetch-error', function() {\n    logger.log('Fetch failed: ' + uri);\n  });\n\n  r.on('fetch-cached', function() {\n    logger.log('[OK] Reusing cached result for ' + uri);\n  });\n\n\n  r.getReadablePath(function(err, fullpath, etag) {\n    if (err) {\n      return onDone(err);\n    }\n\n    r.removeAllListeners('fetch-error');\n    r.removeAllListeners('fetch-cached');\n\n    // according to the NPM source, the version specific JSON is\n    // directly from the index document (e.g. just take doc.versions[ver])\n    var doc = JSON.parse(fs.readFileSync(fullpath));\n\n    // from NPM: if not a valid version, then treat as a tag.\n    if (!(version in doc.versions) && (version in doc['dist-tags'])) {\n      version = doc['dist-tags'][version];\n    }\n    if (doc.versions[version]) {\n      return onDone(undefined, Package._rewriteLocation(doc.versions[version]), etag);\n    }\n    return onDone(new Error('[done] Could not find version', fullpath, version));\n  });\n};\n\nPackage._rewriteLocation = function(meta) {\n  if (!meta) {\n    return meta;\n  }\n\n  if (meta.versions) {\n    // if a full index, apply to all versions\n    Object.keys(meta.versions).forEach(function(version) {\n      meta.versions[version] = Package._rewriteLocation(meta.versions[version]);\n    });\n  }\n\n  if (meta.dist && meta.dist.tarball) {\n    var parts = url.parse(meta.dist.tarball);\n    meta.dist.tarball = externalUrl + parts.pathname;\n  }\n  return meta;\n};\n\nmodule.exports = Package;\n","/home/travis/build/npmtest/node-npmtest-npm_lazy/node_modules/npm_lazy/lib/resource.js":"var fs = require('fs'),\n    coreUrl = require('url'),\n    path = require('path'),\n    // for http get\n    request = require('request'),\n    qs = require('querystring'),\n\n    Lifecycle = require('./lifecycle.js'),\n    verify = require('./verify.js'),\n    microee = require('microee'),\n    Cache;\n\n// maximum age before an index is refreshed from npm\nvar cacheAge = 60 * 60 * 1000,\n    maxRetries = 5,\n    timeout = 10000,\n    rejectUnauthorized = true,\n    logger = console,\n    proxy = {};\n\n// global caches\nvar resourceCache = {},\n    guard = new Lifecycle(),\n    lastUpdated = {};\n\n// A resource is a representation of a particular remote endpoint\n// The main benefit for combining cross-cutting concerns into one object\n// is that it makes expressing the various cases:\n// 1) blocking while fetch is pending\n// 2) retrying when a checksum fails (for a tarfile)\n// 3) delaying the return when the resource is outdated (for a index.json)\n//\n// easier than trying to juggle these responsibilities in the caching logic\n\nfunction Resource(url, auth) {\n  this.url = url;\n  this.auth = auth;\n\n  this.retries = 0;\n\n  var parts = coreUrl.parse(url);\n  if (path.extname(parts.pathname) == '.tgz') {\n    this.type = 'tar';\n    this.basename = path.basename(parts.pathname);\n  } else {\n    this.type = 'index';\n  }\n\n  this.err = null;\n  this.fetchTimer = null;\n}\n\nmicroee.mixin(Resource);\n\nResource.configure = function(opts) {\n  if (typeof opts.cache !== 'undefined') {\n    Cache = opts.cache;\n  }\n  if (typeof opts.cacheAge !== 'undefined') {\n    cacheAge = opts.cacheAge;\n  }\n  if (typeof opts.maxRetries !== 'undefined') {\n    maxRetries = opts.maxRetries;\n  }\n  if (typeof opts.timeout !== 'undefined') {\n    timeout = opts.timeout;\n  }\n  if (typeof opts.rejectUnauthorized !== 'undefined') {\n    rejectUnauthorized = opts.rejectUnauthorized;\n  }\n  if (typeof opts.logger !== 'undefined') {\n    logger = opts.logger;\n  }\n  if (typeof opts.proxy !== 'undefined') {\n    proxy = opts.proxy;\n  }\n};\n\nResource.prototype.exists = function() {\n  // logger.log('exists', this.url, 'GET', Cache.lookup(this.url, 'GET'));\n  return this.lookup().path;\n};\n\nResource.prototype.lookup = function() {\n  return Cache.lookup(this.url, 'GET');\n};\n\nResource.prototype.isUpToDate = function() {\n  if (cacheAge < 0) {\n    return true;\n  }\n  var maxAge = new Date() - cacheAge,\n      isUpToDate = (lastUpdated[this.url] &&\n                    lastUpdated[this.url] > maxAge);\n  return isUpToDate;\n};\n\nResource.prototype.getPackageName = function() {\n  var parts = coreUrl.parse(this.url);\n  var dirs = path.dirname(parts.pathname).split('/').filter(Boolean);\n  if (dirs[0].charAt(0) === '@') {\n    // https://github.com/npm/npm/blob/2a5977e0c65b244e92d848fcd56f2f80ba8cdf3b/lib/utils/map-to-registry.js#L16\n    return dirs.slice(0, 2).join('%2f');\n  }\n  return dirs[0];\n};\n\n// one API\nResource.prototype.getReadablePath = function(onDone) {\n  var self = this;\n  // try to find a shortcut\n  if (!guard.isBlocking(self.url)) {\n    if (self.type == 'index' && self.exists()) {\n      // is this a index file?\n      if (self.isUpToDate()) {\n        self.emit('fetch-cached');\n        // is the index up to date?\n        // yes: return readable stream\n        return onDone(null, self.exists(), self.lookup().etag);\n      }\n    }\n\n    if (self.type == 'tar' && self.exists()) {\n      self.emit('fetch-cached');\n      // is this a tarfile and is it in the index?\n      // yes: check sha1 hash\n      var Package = require('./package.js');\n      return Package.getIndex(self.getPackageName(), self.auth, function(err, data) {\n        if (err) {\n          return onDone(err, null, null);\n        }\n        var expectedHash = verify.getSha(self.basename, data);\n        verify.check(self.exists(), function(err, actualHash) {\n          if (err) {\n            return onDone(err, null, null);\n          }\n          if (actualHash === expectedHash) {\n            return onDone(null, self.exists(), self.lookup().etag); // return readable stream if file is good\n          }\n\n          // otherwise, cache is corrupted somehow, so bust cache and retry\n          logger.log('Cached package is corrupt. Refetching ' + self.url);\n          Cache.junk(self.url);\n          self.getReadablePath(onDone);\n        });\n      });\n    }\n  }\n\n  var removeAtEnd = self.exists();\n\n  // queue the callback\n  guard.onRelease(this.url, function() {\n    // attempt to remove the old file at the end\n    // but do not do this if we fail and decide to reuse an old index\n    if (self.exists() && removeAtEnd && removeAtEnd != self.exists()) {\n      Resource.removeFile(removeAtEnd);\n    }\n    if (self.err && !self.exists()) {\n      return onDone(self.err, null, null);\n    }\n    // return readable path\n    onDone(null, self.exists(), self.lookup().etag);\n  });\n\n  // are we blocking? => nothing more to do so return\n  if (guard.isBlocking(self.url)) {\n    logger.log('Request is pending, blocking ' + self.url);\n    return;\n  }\n\n  // else: queue a get\n  guard.block(self.url);\n  this.retries = 0;\n  this.err = null;\n  this.retry();\n};\n\nResource.prototype.retry = function() {\n  var self = this;\n  self.retries++;\n  if (self.retries > maxRetries || (self.err && self.err.statusCode === 404)) {\n    // if the second fetch fails, and we're fetching an index,\n    // and we have (any) cached version then use that\n    // logger.log(self.retries, self.type, self.exists());\n    if (self.type == 'index' && self.exists()) {\n      self.emit('fetch-cached');\n      Cache.save();\n      return guard.release(self.url);\n    }\n\n    // for non-index files, and index files that we don't have,\n    // if we exhaust the number of retries then 500\n    // did we exceed the max retries? => throw\n    if (!self.err) {\n      self.err = new Error();\n    }\n    self.err.message = 'URL is not in the npm_lazy cache, and it cannot be fetched (max retries exhausted): ' + self.url;\n\n    // We need to read the whole stream because we want to potentially\n    // respond to multiple clients with the same message.\n    // Non-200 responses should be small regardless.\n    var readToEnd = function(stream, done) {\n      var resp = '';\n      stream.on('data', function(content) {\n        resp += content;\n      });\n      stream.on('end', function() {\n        return done(resp);\n      });\n    };\n\n    var done = function(content) {\n      self.err.contentStream = null;\n      self.err.content = content;\n      Cache.save();\n      return guard.release(self.url);\n    };\n\n    if (self.err.contentStream) {\n      return readToEnd(self.err.contentStream, done);\n    }\n    return done('{ \"error\": \"Unknown error\" }');\n  }\n\n  this.fetchTimer = setTimeout(function() {\n    self._afterFetch(new Error('Request timed out (' + timeout + 'ms)'));\n  }, timeout);\n\n  this._fetchTask(function(err, readableStream) {\n    self._afterFetch(err, readableStream);\n  });\n};\n\nResource.prototype._afterFetch = function(err, readableStream) {\n  var self = this;\n\n  clearTimeout(self.fetchTimer);\n  // queue returned:\n\n  // did the request fail?\n  if (err) {\n    err.contentStream = readableStream;\n    self.emit('fetch-error', err, self.retries, maxRetries);\n    // RETRY\n    return self.retry();\n  }\n\n  // resource fetch not modified:\n  if (readableStream.statusCode === 304) {\n    // We can rely on the data already in the cache.\n    // No more operations required.\n    logger.log('[304] ' + self.url);\n    lastUpdated[self.url] = new Date();\n    guard.release(self.url);\n    return;\n  }\n\n  // resource fetch not successful:\n  if (readableStream.statusCode !== 200) {\n    self.err = new Error(readableStream.statusCode + ' getting from upstream: ' + self.url);\n    self.err.statusCode = readableStream.statusCode;\n    self.err.contentStream = readableStream;\n    self.emit('fetch-error-response', self.err, self.retries, maxRetries);\n    logger.log('[' + readableStream.statusCode + '] ' + self.url);\n\n    // RETRY\n    return self.retry();\n  }\n\n  // resource fetch OK:\n  if (readableStream.headers) {\n    self.etag = readableStream.headers.etag;\n  }\n\n  // write to disk\n  var cachename = Cache.filename(),\n      out = fs.createWriteStream(cachename, {flags: 'w'});\n\n  // 0.8.x: \"close\"\n  // 0.10.x: \"finish\"\n  var emittedDone = false;\n  function emitDone() {\n    if (!emittedDone) {\n      emittedDone = true;\n\n      // now validate it\n\n      if (self.type == 'index') {\n        // is this a indexfile?\n        try {\n          // check that it's JSON => store => release\n          JSON.parse(fs.readFileSync(cachename).toString());\n        } catch (e) {\n          // delete\n          Resource.removeFile(cachename);\n          // RETRY\n          return self.retry();\n        }\n        // mark as OK, return all pending callback\n        Cache.complete(self.url, 'GET', cachename, self.etag);\n        // set last updated\n        lastUpdated[self.url] = new Date();\n        guard.release(self.url);\n        return;\n      }\n\n      if (self.type == 'tar') {\n        // is this a tarfile?\n        // read the expected checksum\n        var Package = require('./package.js');\n\n        Package.getIndex(self.getPackageName(), self.auth, function(err, data) {\n          if (err) {\n            self.err = err;\n            return guard.release(self.url);\n          }\n\n          // logger.log('PACKAGE INDEX', data);\n\n          // check that the checksum matches => store => release\n          try {\n            var expected = verify.getSha(self.basename, data);\n          } catch (error) {\n            self.err = error;\n            return guard.release(self.url);\n          }\n          verify.check(cachename, function(err, actual) {\n            if (err || actual !== expected) {\n              logger.error('SHASUM - ' + self.url +\n                ' - expected: ' + expected +\n                ', actual: ' + actual);\n              logger.error('ERROR: npm SHASUM mismatch for ' + self.basename);\n              // delete\n              Resource.removeFile(cachename);\n              // RETRY\n              return self.retry();\n            } else {\n              // must be OK\n              logger.log('[done][SHASUM OK] added to cache',\n                self.url, self.basename, cachename);\n              // mark as OK, return all pending callback\n              Cache.complete(self.url, 'GET', cachename);\n              guard.release(self.url);\n              return;\n            }\n          });\n\n        });\n      }\n    }\n  }\n  out.once('close', emitDone);\n  out.once('finish', emitDone);\n\n  readableStream.pipe(out);\n};\n\nResource.removeFile = function(filepath) {\n  if (fs.existsSync(filepath)) {\n    try {\n      fs.unlinkSync(filepath);\n    } catch (e) { }\n  }\n};\n\nResource.prototype._fetchTask = function(onDone) {\n  var self = this;\n  var opts = {\n        url: coreUrl.parse(this.url),\n        method: 'GET',\n        headers: {}\n      },\n      req,\n      isHttps = (opts.url.protocol == 'https:'),\n      proxyConfig = proxy[(isHttps ? 'https' : 'http')];\n\n  if (proxyConfig && proxyConfig.hostname) {\n      opts.proxy = proxyConfig;\n  }\n\n  if (!rejectUnauthorized && isHttps) {\n    opts.strictSSL = false;\n  }\n\n  if (self.lookup() && self.lookup().etag) {\n    opts.headers['if-none-match'] = self.lookup().etag;\n  }\n\n  if (self.auth) {\n    opts.headers['authorization'] = self.auth;\n  }\n\n  logger.log('[GET] ' + this.url);\n\n  req = request.get(opts);\n  req.on('error', function(err) {\n    onDone(err);\n  });\n\n  req.on('response', function(res) {\n    onDone(null, res);\n  });\n};\n\n// one instance of a resource per url\n\nResource.get = function(url, auth) {\n  if (!resourceCache[url]) {\n    resourceCache[url] = new Resource(url, auth);\n  }\n  return resourceCache[url];\n};\n\nmodule.exports = Resource;\n","/home/travis/build/npmtest/node-npmtest-npm_lazy/node_modules/npm_lazy/lib/lifecycle.js":"var microee = require('microee');\n\nfunction Lifecycle() {\n  this.blocked = {};\n}\n\nmicroee.mixin(Lifecycle);\n\nLifecycle.prototype.block = function(resource) {\n  // console.log('Blocking', resource);\n  this.blocked[resource] = true;\n};\n\nLifecycle.prototype.release = function(resource) {\n  // console.log('Releasing', resource);\n  if (this.isBlocking(resource)) {\n    delete this.blocked[resource];\n    // console.log('Released: '+resource+' - run callbacks');\n    this.emit('resource', resource);\n  }\n};\n\nLifecycle.prototype.isBlocking = function(resource) {\n  return this.blocked.hasOwnProperty(resource);\n};\n\nLifecycle.prototype.onRelease = function(resource, callback) {\n  // console.log('Blocked: '+resource+' - setting callback for release');\n  this.when('resource', function(name) {\n    var isMatch = (name == resource);\n    if (isMatch) {\n      callback();\n    }\n    return isMatch;\n  });\n};\n\nmodule.exports = Lifecycle;\n","/home/travis/build/npmtest/node-npmtest-npm_lazy/node_modules/npm_lazy/lib/verify.js":"var fs = require('fs'),\n    path = require('path');\n\nexports.getSha = function getSha(tarBaseName, json) {\n  var expected;\n  if (!json.versions) {\n    throw new Error('Package index JSON is in unexpected format!' +\n      ' A `.versions` keys is required ' + JSON.stringify(json));\n  }\n\n  // search `versions.nnn.dist.tarball` for the right tarball\n  Object.keys(json.versions).forEach(function(version) {\n    var item = json.versions[version];\n    if (path.basename(item.dist.tarball) == tarBaseName) {\n      expected = item.dist.shasum;\n    }\n  });\n  return expected;\n};\n\nexports.check = function(filename, cb) {\n  // from npm:\n  var crypto = require('crypto');\n  var h = crypto.createHash('sha1'),\n      s = fs.createReadStream(filename),\n      errState = null;\n  s.on('error', function(er) {\n    if (errState) return;\n    return cb(errState = er);\n  }).on('data', function(chunk) {\n    if (errState) return;\n    h.update(chunk);\n  }).on('end', function() {\n    if (errState) return;\n    var actual = h.digest('hex').toLowerCase().trim();\n    cb(null, actual);\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-npm_lazy/node_modules/npm_lazy/lib/etag.js":"var ETag = {\n  handle304: function(req, res, etag) {\n    if (etag) {\n      if (req.headers['if-none-match'] === etag) {\n        res.statusCode = 304;\n        res.end();\n        return;\n      }\n      res.setHeader('ETag', etag);\n    }\n  }\n};\n\nmodule.exports = ETag;\n","/home/travis/build/npmtest/node-npmtest-npm_lazy/node_modules/npm_lazy/lib/cache.js":"var fs = require('fs'),\n    crypto = require('crypto'),\n    path = require('path'),\n    mkdirp = require('mkdirp');\n\nfunction Cache(opts) {\n  this.opts = opts;\n  this.data = null;\n  this.path = opts.path;\n\n  // can either set the path, or set 'appHash'\n  if (opts.path) {\n    this.metaPath = opts.path + '/meta.json';\n    this.data = (fs.existsSync(this.metaPath) ? require(this.metaPath) : {});\n\n    // need to do this early on, since if the path is missing,\n    // writes to the cache dir will fail\n    if (!fs.existsSync(this.opts.path)) {\n      mkdirp.sync(this.opts.path);\n    }\n  } else {\n    throw new Error('Must set the cache path');\n  }\n}\n\nCache.prototype.save = function() {\n  // just in case\n  if (!fs.existsSync(this.opts.path)) {\n    mkdirp.sync(this.opts.path);\n  }\n  fs.writeFileSync(this.metaPath, JSON.stringify(this.data, null, 2));\n};\n\n// invalidates all the cached items for the given inputFilePath\nCache.prototype.junk = function(itemHash) {\n  var self = this;\n  if (!this.data[itemHash]) {\n    return; // nothing to do\n  }\n  // for each .taskResults\n  Object.keys(this.data[itemHash].taskResults).forEach(function(taskHash) {\n    // .taskResults[hash] = { path: '...' }\n    var cacheFile = self.data[itemHash].taskResults[taskHash].path;\n    if (fs.existsSync(cacheFile)) {\n      fs.unlink(cacheFile);\n    }\n  });\n  delete this.data[itemHash];\n};\n\nCache.prototype.clear = function() {\n  var self = this;\n  // delete any lingering files\n  Object.keys(this.data).forEach(function(inputFilePath) {\n    self.junk(inputFilePath);\n  });\n  this.data = {};\n  this.save();\n};\n\nCache.prototype.filename = function() {\n  var cacheName;\n  // generate a new file name\n  do {\n    cacheName = path.normalize(\n      this.path + '/' + Math.random().toString(36).substring(2)\n    );\n  } while (fs.existsSync(cacheName));\n  return cacheName;\n};\n\nCache.prototype.complete = function(itemHash, taskHash, cacheFilePath, etag) {\n  if (arguments.length < 3) {\n    throw new Error('Invalid call to Cache.complete()');\n  }\n\n  if (!this.data[itemHash]) {\n    this.data[itemHash] = { taskResults: {} };\n  }\n  if (!this.data[itemHash].taskResults) {\n    this.data[itemHash].taskResults = {};\n  }\n\n  // make pluggable: update the cache with the INPUT item stats\n\n  this.data[itemHash].taskResults[taskHash] = { path: cacheFilePath, etag: etag };\n  // console.log('Complete', itemHash, taskHash);\n  this.save();\n};\n\nCache.prototype.lookup = function(itemHash, taskHash) {\n  // console.log('Lookup', itemHash, taskHash, this.data[itemHash]);\n  var cacheMeta = this.data[itemHash];\n  // {\n  //   itemHash: {\n  //     stat: (expected stat meta)\n  //     md5: (expected hash meta)\n  //\n  //     taskResults: {\n  //       taskHash: {\n  //         path: (path in cache for this task)\n  //       }\n  //     }\n  //   }\n  // }\n\n  // make pluggable: verification that the looked up item is OK\n\n  // now, search for a cached file that corresponds to the current task hash\n  if (!cacheMeta ||\n      !cacheMeta.taskResults ||\n      !cacheMeta.taskResults[taskHash] ||\n      !cacheMeta.taskResults[taskHash].path) {\n    return false;\n  }\n  return cacheMeta.taskResults[taskHash];\n};\n\nCache.hash = Cache.prototype.hash = function(method, str) {\n  // method is optional, defaults to md5\n  if (arguments.length === 1) {\n    str = method;\n    method = 'md5';\n  }\n  return crypto.createHash(method).update(str).digest('hex');\n};\n\nmodule.exports = Cache;\n\n","/home/travis/build/npmtest/node-npmtest-npm_lazy/node_modules/npm_lazy/config.js":"var path = require('path'),\n    homePath = path.normalize(process.env[(process.platform == 'win32') ? 'USERPROFILE' : 'HOME']);\n\nmodule.exports = {\n  // Logging config\n  loggingOpts: {\n\n\t// show the ip address of the machine requesting the npm package\n    logRequesterIP: true,\n    // Print to stdout with colors\n    logToConsole: true,\n    // Write to file\n    logToFile: false,\n\n    // This should be a file path.\n    filename: homePath + '/npm_lazy.log'\n  },\n\n  // Cache config\n\n  // `cacheDirectory`: Directory to store cached packages.\n  //\n  // Note: Since any relative path is resolved relative to the current working\n  // directory when the server is started, you should use a full path.\n\n  cacheDirectory: homePath + '/.npm_lazy',\n\n  // `cacheAge`: maximum age before an index is refreshed from remoteUrl\n  // - negative value means no refresh (e.g. once cached, never update the package.json metadata)\n  // - zero means always refresh (e.g. always ask the registry for metadata)\n  // - positive value means refresh every n milliseconds\n  //   (e.g. 60 * 60 * 1000 = expire metadata every 60 minutes)\n  //\n  // Note: if you want to use `npm star` and other methods which update\n  // npm metadata, you will need to set cacheAge to 0. npm generally wants the latest\n  // package metadata version so caching package metadata will interfere with it.\n\n  // Recommended setting: 0\n  cacheAge: 0,\n\n  // Request config\n\n  // max milliseconds to wait for each HTTP response\n  httpTimeout: 10000,\n  // maximum number of retries per HTTP resource to get\n  maxRetries: 5,\n  // whether or not HTTPS requests are checked against Node's list of CAs\n  // set false if you are using your own npm mirror with a self-signed SSL cert\n  rejectUnauthorized: true,\n\n  // Remote and local URL\n\n  // external url to npm_lazy, no trailing /\n  externalUrl: 'http://localhost:8080',\n  // registry url with trailing /\n  remoteUrl: 'https://registry.npmjs.com/',\n  // bind port and host\n  port: 8080,\n  host: '0.0.0.0',\n\n  // Proxy config\n  // You can also configure this using the http_proxy and https_proxy environment variables\n  // cf. https://wiki.archlinux.org/index.php/proxy_settings\n  proxy: {\n    // http: 'http://1.2.3.4:80/',\n    // https: 'http://4.3.2.1:80/'\n  }\n};\n"}